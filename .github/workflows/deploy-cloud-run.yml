name: Deploy to Cloud Run on Merge

on:
  push:
    branches:
      - main

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    env:
      # Default to repository variables; will be overridden by JSON if present
      GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
      GCP_REGION: ${{ vars.GCP_REGION }}
      GCP_WIF_PROVIDER: ${{ vars.GCP_WIF_PROVIDER }}
      GCP_DEPLOY_SA: ${{ vars.GCP_DEPLOY_SA }}
      CLOUD_RUN_RUNTIME_SA: ${{ vars.CLOUD_RUN_RUNTIME_SA }}
      CLOUD_RUN_API_SERVICE: ${{ vars.CLOUD_RUN_API_SERVICE }}
      CLOUD_RUN_JOBS_SERVICE: ${{ vars.CLOUD_RUN_JOBS_SERVICE }}
      # Pub/Sub topic (stable per env) used by producer/consumer
      PUBSUB_TOPIC: ${{ vars.PUBSUB_TOPIC }}
      # Disable any gcloud interactive prompts in CI
      CLOUDSDK_CORE_DISABLE_PROMPTS: '1'
      CLOUDSDK_COMPONENT_MANAGER_DISABLE_UPDATE_CHECK: '1'

    steps:
      - uses: actions/checkout@v4

      - name: Load env from .github/actions-variables.json (if present)
        run: |
          set -euo pipefail
          FILE=".github/actions-variables.json"
          if [ -f "$FILE" ]; then
            echo "Loading variables from $FILE"
            jq -r 'to_entries[] | [.key, .value] | @tsv' "$FILE" | while IFS=$'\t' read -r key val; do
              printf '%s=%s\n' "$key" "$val" >> "$GITHUB_ENV"
            done
          else
            echo "No $FILE found; using repository Variables"
          fi

      - name: Authenticate to Google Cloud (WIF/OIDC)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WIF_PROVIDER }}
          service_account: ${{ env.GCP_DEPLOY_SA }}
          token_format: access_token

      - name: Setup gcloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          install_components: beta

      - name: Ensure gcloud beta component is installed (non-interactive)
        run: |
          set -euo pipefail
          gcloud components install beta --quiet
          # Sanity check to ensure beta is available and suppress any prompts
          gcloud --quiet beta --version >/dev/null || true

      - name: Configure gcloud
        run: |
          gcloud config set project "${GCP_PROJECT_ID}"
          gcloud config set run/region "${GCP_REGION}"

      # Deploy Firestore composite indexes using gcloud (WIF auth)
      - name: Deploy Firestore indexes (from firestore.indexes.json)
        if: ${{ hashFiles('firestore.indexes.json') != '' }}
        shell: bash
        run: |
          set -euo pipefail
          FILE="firestore.indexes.json"
          if [[ ! -f "$FILE" ]]; then
            echo "No $FILE found; skipping Firestore indexes deploy"
            exit 0
          fi

          count=$(jq '.indexes | length' "$FILE")
          if [[ "$count" -eq 0 ]]; then
            echo "No composite indexes defined; skipping"
            exit 0
          fi

          # Iterate indexes and create via gcloud
          jq -c '.indexes[]' "$FILE" | while read -r idx; do
            collection=$(echo "$idx" | jq -r '.collectionGroup')
            scope=$(echo "$idx" | jq -r '.queryScope // "COLLECTION"')

            # Build repeated --field-config flags with correct keys
            mapfile -t fieldFlags < <(
              echo "$idx" | jq -r '
                .fields[] |
                if has("order") then
                  "--field-config=field-path=" + .fieldPath + ",order=" + .order
                else
                  "--field-config=field-path=" + .fieldPath + ",array-config=" + .arrayConfig
                end'
            )

            echo "Creating index for collectionGroup=${collection}, queryScope=${scope}"
            # shellcheck disable=SC2086
            gcloud --quiet beta firestore indexes composite create \
              --collection-group="${collection}" \
              --query-scope="${scope}" \
              ${fieldFlags[*]} \
              || echo "Index may already exist or is being built; continuing"
          done

      # Build --set-secrets flag from secrets.txt (Secret Manager keys listed one per line)
      - name: Build --set-secrets flag from secrets.txt
        id: secrets
        run: |
          # Cloud Run expects ENV=SECRET:VERSION (optionally :PROJECT for cross-project).
          # Using same-project secrets, so we omit the projects/... path used by Cloud Functions.
          if [[ -f secrets.txt ]]; then
            secret_list=$(grep -vE '^\s*#' secrets.txt | grep -vE '^\s*$' | awk '{print $1"="$1":latest"}' | paste -sd "," -)
            if [[ -n "${secret_list}" ]]; then
              echo "SECRET_FLAGS=--set-secrets=${secret_list}" >> "$GITHUB_OUTPUT"
            else
              echo "SECRET_FLAGS=" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "secrets.txt not found; continuing without --set-secrets"
            echo "SECRET_FLAGS=" >> "$GITHUB_OUTPUT"
          fi

      # Configure Docker auth for Artifact Registry
      - name: Configure Docker auth for Artifact Registry
        run: |
          gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet

      # Build and push Producer image
      - name: Build and push Producer image
        id: producer_image
        run: |
          set -euo pipefail
          PRODUCER_IMAGE_URI="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/app/producer:${GITHUB_SHA}"
          echo "PRODUCER_IMAGE_URI=${PRODUCER_IMAGE_URI}" >> "$GITHUB_OUTPUT"
          docker build -t "${PRODUCER_IMAGE_URI}" cloud/producer
          docker push "${PRODUCER_IMAGE_URI}"

      # Build and push Consumer image
      - name: Build and push Consumer image
        id: consumer_image
        run: |
          set -euo pipefail
          CONSUMER_IMAGE_URI="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/app/sse-consumer:${GITHUB_SHA}"
          echo "CONSUMER_IMAGE_URI=${CONSUMER_IMAGE_URI}" >> "$GITHUB_OUTPUT"
          docker build -t "${CONSUMER_IMAGE_URI}" cloud/sse-consumer
          docker push "${CONSUMER_IMAGE_URI}"

      # Create/replace Producer Cloud Run Job (no sidecar)
      - name: Create/replace Producer Cloud Run Job (no sidecar)
        shell: bash
        env:
          PRODUCER_CLOUD_RUN_JOB_NAME: ${{ vars.PRODUCER_CLOUD_RUN_JOB_NAME }}
          PRODUCER_IMG: ${{ steps.producer_image.outputs.PRODUCER_IMAGE_URI }}
          PRODUCER_JOB_SA_EMAIL: ${{ vars.PRODUCER_JOB_SA_EMAIL }}
          CLOUD_RUN_RUNTIME_SA: ${{ env.CLOUD_RUN_RUNTIME_SA }}
        run: |
          set -euo pipefail
          : "${PRODUCER_CLOUD_RUN_JOB_NAME?Set repo var PRODUCER_CLOUD_RUN_JOB_NAME}"
          : "${PRODUCER_IMG?missing}"
          SA_EMAIL="${PRODUCER_JOB_SA_EMAIL:-$CLOUD_RUN_RUNTIME_SA}"

          sed -e "s|__JOB_NAME__|${PRODUCER_CLOUD_RUN_JOB_NAME}|g" \
              -e "s|__SERVICE_ACCOUNT__|${SA_EMAIL}|g" \
              -e "s|__PRODUCER_IMAGE__|${PRODUCER_IMG}|g" \
              -e "s|__TOPIC__|${PUBSUB_TOPIC}|g" \
              cloud/producer/job.yaml > /tmp/producer.job.rendered.yaml

          gcloud run jobs replace /tmp/producer.job.rendered.yaml --region="${GCP_REGION}" --project="${GCP_PROJECT_ID}"

      # Create/replace Consumer Cloud Run Job (Pub/Sub only)
      - name: Create/replace Consumer Cloud Run Job (Pub/Sub only)
        shell: bash
        env:
          CONSUMER_CLOUD_RUN_JOB_NAME: ${{ vars.CONSUMER_CLOUD_RUN_JOB_NAME }}
          CONSUMER_IMG: ${{ steps.consumer_image.outputs.CONSUMER_IMAGE_URI }}
          CONSUMER_JOB_SA_EMAIL: ${{ vars.CONSUMER_JOB_SA_EMAIL }}
          CLOUD_RUN_RUNTIME_SA: ${{ env.CLOUD_RUN_RUNTIME_SA }}
        run: |
          set -euo pipefail
          : "${CONSUMER_CLOUD_RUN_JOB_NAME?Set repo var CONSUMER_CLOUD_RUN_JOB_NAME}"
          : "${CONSUMER_IMG?missing}"
          SA_EMAIL="${CONSUMER_JOB_SA_EMAIL:-$CLOUD_RUN_RUNTIME_SA}"

          sed -e "s|__JOB_NAME__|${CONSUMER_CLOUD_RUN_JOB_NAME}|g" \
              -e "s|__SERVICE_ACCOUNT__|${SA_EMAIL}|g" \
              -e "s|__CONSUMER_IMAGE__|${CONSUMER_IMG}|g" \
              -e "s|__TOPIC__|${PUBSUB_TOPIC}|g" \
              cloud/consumer/job.yaml > /tmp/consumer.job.rendered.yaml

          gcloud run jobs replace /tmp/consumer.job.rendered.yaml --region="${GCP_REGION}" --project="${GCP_PROJECT_ID}"

      # Build and push API image
      - name: Build and push image to Artifact Registry
        id: image
        run: |
          set -euo pipefail
          IMAGE_URI="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/app/api:${GITHUB_SHA}"
          echo "IMAGE_URI=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          docker build -t "${IMAGE_URI}" .
          docker push "${IMAGE_URI}"

      - name: Deploy API service (public)
        run: |
          gcloud run deploy "${CLOUD_RUN_API_SERVICE}" \
            --quiet \
            --region="${GCP_REGION}" \
            --image="${{ steps.image.outputs.IMAGE_URI }}" \
            --service-account="${CLOUD_RUN_RUNTIME_SA}" \
            --allow-unauthenticated \
            --timeout=3600 \
            --set-env-vars="NODE_ENV=production,SERVICE_TARGET=start:api,GCP_PROJECT=${GCP_PROJECT_ID},ALLOW_SKIP_AUTH=0,WORKFLOWS_BASE_URL=${WORKFLOWS_BASE_URL}" \
            ${{ steps.secrets.outputs.SECRET_FLAGS }}

      - name: Deploy Jobs service (auth-required)
        run: |
          gcloud run deploy "${CLOUD_RUN_JOBS_SERVICE}" \
            --quiet \
            --region="${GCP_REGION}" \
            --image="${{ steps.image.outputs.IMAGE_URI }}" \
            --service-account="${CLOUD_RUN_RUNTIME_SA}" \
            --no-allow-unauthenticated \
            --timeout=3600 \
            --set-env-vars="NODE_ENV=production,SERVICE_TARGET=start:jobs,GCP_PROJECT=${GCP_PROJECT_ID},ALLOW_SKIP_AUTH=0,WORKFLOWS_BASE_URL=${WORKFLOWS_BASE_URL},PRODUCER_CLOUD_RUN_JOB_NAME=${PRODUCER_CLOUD_RUN_JOB_NAME},CONSUMER_CLOUD_RUN_JOB_NAME=${{ vars.CONSUMER_CLOUD_RUN_JOB_NAME }},CLOUD_RUN_LOCATION=${GCP_REGION}" \
            ${{ steps.secrets.outputs.SECRET_FLAGS }}

# Notes:
# - Producer and Consumer both run as Cloud Run Jobs with their own service accounts.
# - Communication is Pub/Sub-only; no HTTP sidecar or direct service-to-service calls.
# - The Jobs service orchestrates per-run ephemeral Pub/Sub subscriptions and triggers both Jobs with per-run env overrides.
